defmodule Wayfarer.Dsl.HealthCheck do
  @moduledoc """
  A struct for storing a health-check generated by the DSL.
  """

  alias Spark.Dsl.Entity

  @defaults [
    connect_timeout: :timer.seconds(5),
    interval: :timer.seconds(30),
    method: :get,
    path: "/",
    response_timeout: 500,
    success_codes: [200..299],
    threshold: 3
  ]

  defstruct connect_timeout: @defaults[:connect_timeout],
            hostname: nil,
            interval: @defaults[:interval],
            method: @defaults[:method],
            name: nil,
            path: @defaults[:path],
            response_timeout: @defaults[:response_timeout],
            success_codes: @defaults[:success_codes],
            threshold: @defaults[:threshold]

  @type t :: %__MODULE__{
          connect_timeout: pos_integer,
          hostname: nil | String.t(),
          interval: pos_integer,
          method: :get | :head | :port | :put | :delete | :connect | :options | :trace | :patch,
          name: nil | String.t(),
          path: String.t(),
          response_timeout: pos_integer,
          success_codes: [Range.t(100, 599)],
          threshold: pos_integer
        }

  @schema [
    name: [
      type: {:or, [:string, nil]},
      required: false,
      doc: "A unique name for the health check."
    ],
    method: [
      type: {:in, [:get, :head, :post, :put, :delete, :connect, :options, :trace, :patch]},
      required: false,
      default: @defaults[:method],
      doc: "The HTTP method to use for the request."
    ],
    connect_timeout: [
      type: :pos_integer,
      required: false,
      default: @defaults[:connect_timeout],
      doc: "Connection timeout in milliseconds"
    ],
    response_timeout: [
      type: :pos_integer,
      required: false,
      default: @defaults[:response_timeout],
      doc: "Response timeout in milliseconds"
    ],
    hostname: [
      type: {:or, [nil, :string]},
      required: false,
      doc: "The HTTP hostname to use when sending the request.  Defaults to the IP address."
    ],
    interval: [
      type: :pos_integer,
      required: false,
      default: @defaults[:interval],
      doc: "Interval in milliseconds"
    ],
    threshold: [
      type: :pos_integer,
      required: false,
      default: @defaults[:threshold],
      doc: "Success threshold"
    ],
    path: [
      type: :string,
      required: false,
      default: @defaults[:path],
      doc: "Path"
    ],
    success_codes: [
      type: {:wrap_list, {:or, [{:struct, Range}, {:in, 100..500}]}},
      required: false,
      default: @defaults[:success_codes],
      doc: "HTTP status codes which are considered successful."
    ]
  ]

  @doc false
  @spec default :: t
  def default, do: struct(__MODULE__, @defaults)

  @doc false
  @spec to_options(t) :: keyword()
  def to_options(check) do
    check
    |> Map.from_struct()
    |> Enum.to_list()
  end

  @doc false
  @spec entities :: [Entity.t()]
  def entities do
    [
      %Entity{
        name: :check,
        target: __MODULE__,
        schema: @schema,
        args: [{:optional, :name, nil}],
        transform: {__MODULE__, :transform, []}
      }
    ]
  end

  @doc false
  @spec schema :: NimbleOptions.schema()
  def schema, do: @schema

  @doc false
  @spec transform(t) :: {:ok, t} | {:error, any}
  def transform(check) do
    with {:ok, success_codes} <- transform_success_codes(check.success_codes) do
      maybe_set_name(%{check | success_codes: success_codes})
    end
  end

  defguardp is_valid_status_code?(code) when is_integer(code) and code >= 100 and code <= 599

  defguardp is_valid_range?(range)
            when is_struct(range, Range) and is_valid_status_code?(range.first) and
                   is_valid_status_code?(range.last)

  defp transform_success_codes(range) when is_valid_range?(range), do: {:ok, [range]}
  defp transform_success_codes([]), do: {:ok, []}

  defp transform_success_codes([head | tail]) when is_valid_range?(head) do
    with {:ok, tail} <- transform_success_codes(tail) do
      {:ok, [head | tail]}
    end
  end

  defp transform_success_codes([head | tail])
       when is_integer(head) and is_valid_status_code?(head) do
    with {:ok, tail} <- transform_success_codes(tail) do
      {:ok, [head..head | tail]}
    end
  end

  defp transform_success_codes([range | _]),
    do: {:error, "Value `#{inspect(range)}` is not valid. Must be a range between 100..599"}

  defp maybe_set_name(check) when is_binary(check.name), do: {:ok, check}

  defp maybe_set_name(check) do
    name =
      check.success_codes
      |> Enum.map_join(",", &"#{&1.first}..#{&1.last}")
      |> then(&"#{check.path}:[#{&1}]")

    {:ok, %{check | name: name}}
  end
end
