defmodule Wayfarer.Dsl.Config do
  @moduledoc """
  The struct for storing configurations as generated by the DSL.
  """

  alias Spark.Dsl.Entity
  alias Wayfarer.Dsl.{HealthChecks, HostPatterns, Listeners, Targets}

  defstruct __identifier__: nil,
            health_checks: HealthChecks.init(),
            host_patterns: HostPatterns.init(),
            listeners: Listeners.init(),
            name: nil,
            targets: Targets.init()

  @type t :: %__MODULE__{
          __identifier__: any,
          health_checks: HealthChecks.t(),
          host_patterns: HostPatterns.t(),
          listeners: Listeners.t(),
          name: nil | String.t(),
          targets: Targets.t()
        }

  @doc false
  @spec entities :: [Entity.t()]
  def entities do
    [
      %Entity{
        name: :config,
        target: __MODULE__,
        schema: [
          name: [
            type: :string,
            required: false
          ]
        ],
        entities: [
          health_checks: HealthChecks.entities(),
          host_patterns: HostPatterns.entities(),
          listeners: Listeners.entities(),
          targets: Targets.entities()
        ],
        singleton_entity_keys: [:health_checks, :host_patterns, :listeners, :targets],
        args: [{:optional, :name, nil}],
        transform: {__MODULE__, :transform, []}
      }
    ]
  end

  @doc false
  @spec transform(t) :: {:ok, t} | {:error, any}
  def transform(config) do
    with :ok <- verify_at_least_one_listener(config),
         :ok <- verify_at_least_one_target(config) do
      {:ok, config}
    end
  end

  defp verify_at_least_one_listener(config) when config.listeners.listeners == [],
    do: {:error, "Must provide at least one listener to accept incoming connections."}

  defp verify_at_least_one_listener(_config), do: :ok

  defp verify_at_least_one_target(config) when config.targets.targets == [],
    do: {:error, "Must provide at least one target to send requests to."}

  defp verify_at_least_one_target(_config), do: :ok
end
