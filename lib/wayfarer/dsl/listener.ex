defmodule Wayfarer.Dsl.Listener do
  @moduledoc """
  A struct for storing a listener generated by the DSL.
  """

  alias Spark.Dsl.Entity
  alias Wayfarer.Utils

  defstruct address: nil,
            certfile: nil,
            cipher_suite: nil,
            http_1_options: [],
            http_2_options: [],
            keyfile: nil,
            name: nil,
            port: nil,
            scheme: :http,
            thousand_island_options: [],
            uri: nil,
            websocket_options: []

  @type t :: %__MODULE__{
          address: IP.Address.t(),
          certfile: nil | String.t(),
          cipher_suite: nil | :strong | :compatible,
          http_1_options: Bandit.http_1_options(),
          http_2_options: Bandit.http_2_options(),
          keyfile: nil | String.t(),
          name: nil | String.t(),
          port: :inet.port_number(),
          scheme: :http | :https,
          thousand_island_options: ThousandIsland.options(),
          uri: URI.t(),
          websocket_options: Bandit.websocket_options()
        }

  @http_schema [
    scheme: [
      type: {:in, [:http, :https]},
      required: true,
      doc: "The listening protocol."
    ],
    address: [
      type: {:or, [{:struct, IP.Address}, :string]},
      required: true,
      doc: "The address of the interface to listen on."
    ],
    name: [
      type: {:or, [nil, :string]},
      required: false,
      doc: "A unique name for the listener (defaults to the URI)."
    ],
    port: [
      type: :pos_integer,
      required: true,
      doc: "The TCP port on which to listen for incoming connections."
    ],
    http_1_options: [
      type: :keyword_list,
      required: false,
      default: [],
      doc: "Options to configure the HTTP/1 stack in Bandit."
    ],
    http_2_options: [
      type: :keyword_list,
      required: false,
      default: [],
      doc: "Options to configure the HTTP/2 stack in Bandit."
    ],
    thousand_island_options: [
      type: :keyword_list,
      required: false,
      default: [],
      doc: "Possible options to configure a ThousandIsland server."
    ],
    websocket_options: [
      type: :keyword_list,
      required: false,
      default: [],
      doc: "Options to configure the WebSocket stack in Bandit."
    ]
  ]

  @https_schema @http_schema ++
                  [
                    certfile: [
                      type: :string,
                      required: false,
                      doc:
                        "The path to a file containing the SSL certificate to use for this listener."
                    ],
                    keyfile: [
                      type: :string,
                      required: false,
                      doc: "The path to a file containing the SSL key to use for this listener."
                    ],
                    cipher_suite: [
                      type: {:in, [nil, :strong, :compatible]},
                      required: false,
                      doc:
                        "Used to define a pre-selected set of ciphers, as described by `Plug.SSL.configure/1`."
                    ]
                  ]

  @doc false
  @spec entities :: [Entity.t()]
  def entities do
    [
      %Entity{
        name: :http,
        target: __MODULE__,
        schema: @http_schema,
        auto_set_fields: [scheme: :http],
        args: [:address, :port],
        imports: [IP.Sigil],
        transform: {__MODULE__, :transform, []}
      },
      %Entity{
        name: :https,
        target: __MODULE__,
        schema: @https_schema,
        auto_set_fields: [scheme: :https],
        args: [:address, :port],
        imports: [IP.Sigil],
        transform: {__MODULE__, :transform, []}
      }
    ]
  end

  @doc false
  @spec transform(t) :: {:ok, t} | {:error, any}
  def transform(listener) do
    with :ok <- validate_cert_and_key(listener),
         {:ok, listener} <- maybe_parse_address(listener),
         {:ok, listener} <- set_uri(listener) do
      maybe_set_name(listener)
    end
  end

  @doc false
  @spec schema :: NimbleOptions.schema()
  def schema,
    do:
      @https_schema
      |> make_optional(:certfile)
      |> make_optional(:keyfile)
      |> make_optional(:cipher_suite)

  defp make_optional(schema, field) do
    schema
    |> Keyword.update!(field, fn config ->
      config
      |> Keyword.put(:required, false)
      |> Keyword.update!(:type, &{:or, [nil, &1]})
    end)
  end

  defp validate_cert_and_key(listener) when listener.scheme == :http, do: :ok

  defp validate_cert_and_key(listener)
       when is_binary(listener.certfile) and is_binary(listener.keyfile),
       do: :ok

  defp validate_cert_and_key(_listener),
    do: {:error, "Both `certfile` and `keyfile` options must be set for an HTTPS listener."}

  defp maybe_parse_address(listener) when is_struct(listener.address, IP.Address),
    do: {:ok, listener}

  defp maybe_parse_address(listener) when is_binary(listener.address) do
    with {:ok, address} <- IP.Address.from_string(listener.address) do
      {:ok, %{listener | address: address}}
    end
  end

  defp set_uri(listener) do
    with {:ok, uri} <- Utils.to_uri(listener.scheme, listener.address, listener.port) do
      {:ok, %{listener | uri: uri}}
    end
  end

  defp maybe_set_name(listener) when is_binary(listener.name), do: {:ok, listener}
  defp maybe_set_name(listener), do: {:ok, %{listener | name: to_string(listener.uri)}}
end
